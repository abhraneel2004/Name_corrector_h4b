{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/ai/ai-instance.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\n/**\n * Logger function for Gemini API calls\n * Can be imported and used wherever Gemini API is being used\n */\nexport function logGeminiAPICall(context: string): void {\n  console.log(`🌐 [GEMINI API] ${context}`);\n}\n\n// Create the AI instance\nexport const ai = genkit({\n  promptDir: './prompts',\n  plugins: [\n    googleAI({\n      apiKey: process.env.GOOGLE_GENAI_API_KEY,\n    }),\n  ],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;;;AAMO,SAAS,iBAAiB,OAAe;IAC9C,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,SAAS;AAC1C;AAGO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,WAAW;IACX,SAAS;QACP,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD,EAAE;YACP,QAAQ,QAAQ,GAAG,CAAC,oBAAoB;QAC1C;KACD;IACD,OAAO;AACT","debugId":null}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/services/indian-name-validator-server.ts"],"sourcesContent":["/**\n * Represents information about a name, including its validity.\n */\nexport interface NameInfo {\n  /**\n   * Indicates whether the name is valid or not.\n   */\n  isValid: boolean;\n  /**\n   * An optional message providing additional information about the name.\n   */\n  message?: string;\n  /**\n   * An optional suggested correction for an invalid name.\n   */\n  suggestion?: string;\n}\n\n/**\n * Represents a name correction entry\n */\nexport interface NameCorrection {\n  /**\n   * The original name\n   */\n  original: string;\n  /**\n   * The corrected name\n   */\n  corrected: string;\n  /**\n   * Whether a correction was made\n   */\n  needsCorrection: boolean;\n  /**\n   * Optional reason for the correction\n   */\n  reason?: string;\n}\n\n// List of common Indian first names and last names for validation\nconst commonIndianFirstNames = [\n  'Aditya', 'Amit', 'Ananya', 'Arjun', 'Aryan', 'Aishwarya', 'Anil', 'Anjali',\n  'Deepa', 'Deepak', 'Divya', 'Gaurav', 'Isha', 'Karan', 'Kavita', 'Krishna',\n  'Manish', 'Meera', 'Mohan', 'Neha', 'Nikhil', 'Pooja', 'Priya', 'Rahul',\n  'Raj', 'Rajesh', 'Rakesh', 'Ravi', 'Sachin', 'Sanjay', 'Sarika', 'Shikha',\n  'Shiv', 'Sneha', 'Sunil', 'Sunita', 'Suresh', 'Tanvi', 'Varun', 'Vijay',\n  'Vikram', 'Viren', 'Vivek', 'Yash'\n];\n\nconst commonIndianLastNames = [\n  'Agarwal', 'Bansal', 'Bhatia', 'Chauhan', 'Chopra', 'Das', 'Dutta', 'Gandhi',\n  'Gupta', 'Jain', 'Joshi', 'Kapoor', 'Khan', 'Kumar', 'Malhotra', 'Mehta',\n  'Mishra', 'Nair', 'Patel', 'Rao', 'Reddy', 'Saxena', 'Sharma', 'Singh',\n  'Sinha', 'Verma', 'Yadav', 'Iyer', 'Pillai', 'Desai', 'Shah', 'Mukherjee',\n  'Chatterjee', 'Bose', 'Banerjee', 'Patil', 'Kaur', 'Mehra', 'Menon', 'Gill'\n];\n\n// Regex patterns for validation\nconst nameRegexPattern = /^[A-Za-z\\s.'-]+$/;\nconst specialCharPattern = /[^A-Za-z\\s.'-]/;\nconst excessiveSpecialCharPattern = /[.'-]{2,}/;\n\n// Name validation types\nexport interface NameValidationResult {\n  isValid: boolean;\n  name: string;\n  confidence: number;\n  issues: string[];\n  suggestions: string[];\n  message?: string;\n}\n\n// Common Indian naming patterns and rules\nconst commonIssues = {\n  tooShort: 'Name is too short',\n  noSpaces: 'Full name should contain at least first and last name',\n  incorrectCapitalization: 'Name should be properly capitalized',\n  specialCharacters: 'Name contains invalid special characters',\n  numbersPresent: 'Name should not contain numbers',\n  excessiveSpaces: 'Name contains excessive spaces',\n  missingLastName: 'Indian names typically include a last name'\n};\n\n// Basic validation checks\nconst validateBasicRules = (name: string): { issues: string[], confidence: number } => {\n  const issues: string[] = [];\n  let confidence = 100;\n  \n  // Check name length\n  if (name.length < 3) {\n    issues.push(commonIssues.tooShort);\n    confidence -= 30;\n  }\n  \n  // Check for numbers\n  if (/\\d/.test(name)) {\n    issues.push(commonIssues.numbersPresent);\n    confidence -= 40;\n  }\n  \n  // Check for invalid special characters (allowing periods and hyphens)\n  if (/[^a-zA-Z\\u0900-\\u097F\\s.\\-]/u.test(name)) {\n    issues.push(commonIssues.specialCharacters);\n    confidence -= 30;\n  }\n  \n  // Check for excessive spaces\n  if (/\\s{2,}/.test(name)) {\n    issues.push(commonIssues.excessiveSpaces);\n    confidence -= 15;\n  }\n  \n  // Check for proper capitalization (each name part should be capitalized)\n  const nameParts = name.trim().split(/\\s+/);\n  const allProperlyCapitalized = nameParts.every(part => \n    part.length > 0 && part[0] === part[0].toUpperCase() && part.slice(1) === part.slice(1).toLowerCase()\n  );\n  \n  if (!allProperlyCapitalized) {\n    issues.push(commonIssues.incorrectCapitalization);\n    confidence -= 20;\n  }\n  \n  // Check for full name (first and last name)\n  if (nameParts.length < 2) {\n    issues.push(commonIssues.missingLastName);\n    confidence -= 15;\n  }\n  \n  return { issues, confidence: Math.max(0, confidence) };\n};\n\n// Generate suggestions for fixing identified issues\nconst generateSuggestions = (name: string, issues: string[]): string[] => {\n  const suggestions: string[] = [];\n  const nameParts = name.trim().split(/\\s+/);\n  \n  // Fix capitalization\n  if (issues.includes(commonIssues.incorrectCapitalization)) {\n    const properlyCapitalized = nameParts.map(part => \n      part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()\n    ).join(' ');\n    \n    suggestions.push(properlyCapitalized);\n  }\n  \n  // Fix excessive spaces\n  if (issues.includes(commonIssues.excessiveSpaces)) {\n    const fixedSpaces = name.replace(/\\s+/g, ' ').trim();\n    suggestions.push(fixedSpaces);\n  }\n  \n  // If name is missing last name, suggest common Indian last names\n  if (issues.includes(commonIssues.missingLastName) && nameParts.length === 1) {\n    const commonLastNames = ['Sharma', 'Patel', 'Singh', 'Kumar', 'Verma', 'Rao', 'Reddy', 'Nair', 'Joshi'];\n    const firstName = nameParts[0].charAt(0).toUpperCase() + nameParts[0].slice(1).toLowerCase();\n    \n    // Add 3 random last name suggestions\n    for (let i = 0; i < 3; i++) {\n      const randomLastName = commonLastNames[Math.floor(Math.random() * commonLastNames.length)];\n      suggestions.push(`${firstName} ${randomLastName}`);\n    }\n  }\n  \n  return [...new Set(suggestions)]; // Remove duplicates\n};\n\n/**\n * Validates an Indian name and returns detailed validation results\n * @param name The name to validate\n * @returns Validation result with confidence score, issues, and suggestions\n */\nexport async function validateIndianName(name: string): Promise<NameValidationResult> {\n  console.log(`[SERVER] Validating Indian name: \"${name}\"`);\n  \n  // Basic input validation\n  if (!name || typeof name !== 'string') {\n    throw new Error('Invalid input: Name must be a non-empty string');\n  }\n  \n  // Trim the name to remove leading/trailing whitespace\n  const trimmedName = name.trim();\n  \n  // Perform our own validation checks\n  const { issues, confidence } = validateBasicRules(trimmedName);\n  \n  // Generate suggestions for improvement\n  const suggestions = generateSuggestions(trimmedName, issues);\n  \n  // Determine if the name is valid based on confidence threshold\n  const isValid = confidence > 70;\n  \n  // Create a summary message from the first issue (if any)\n  const message = issues.length > 0 ? issues[0] : isValid ? 'Valid Indian name' : undefined;\n  \n  const result = {\n    isValid,\n    name: trimmedName,\n    confidence,\n    issues,\n    suggestions,\n    message\n  };\n  \n  console.log(`[SERVER] Validation result for \"${name}\":`, { isValid, confidence, issuesCount: issues.length });\n  \n  return result;\n}\n\n/**\n * Batch validates multiple Indian names or separate first and last names\n * @param firstParam Array of names or first names\n * @param lastNames Optional array of last names\n * @returns Array of validation results or object with first/last name corrections\n */\nexport async function batchValidateIndianNames(names: string[]): Promise<NameValidationResult[]>;\nexport async function batchValidateIndianNames(\n  firstNames: string[], \n  lastNames: string[]\n): Promise<{\n  firstNameCorrections: NameCorrection[],\n  lastNameCorrections: NameCorrection[]\n}>;\nexport async function batchValidateIndianNames(\n  firstParam: string[],\n  secondParam?: string[]\n): Promise<NameValidationResult[] | {\n  firstNameCorrections: NameCorrection[],\n  lastNameCorrections: NameCorrection[]\n}> {\n  // If only one parameter provided, it's the names array\n  if (!secondParam) {\n    console.log(`[SERVER] Batch validating ${firstParam.length} names`);\n    \n    if (!Array.isArray(firstParam)) {\n      throw new Error('Invalid input: Names must be provided as an array');\n    }\n    \n    // Process each name in parallel\n    const validationPromises = firstParam.map(name => validateIndianName(name));\n    const results = await Promise.all(validationPromises);\n    \n    console.log(`[SERVER] Completed batch validation of ${results.length} names`);\n    \n    return results;\n  }\n  \n  // Otherwise, we're dealing with firstNames and lastNames\n  const firstNames = firstParam;\n  const lastNames = secondParam;\n  \n  console.log(`[SERVER] Batch validating ${firstNames.length} first names and ${lastNames.length} last names`);\n  \n  // Process first names\n  const firstNameCorrections: NameCorrection[] = [];\n  for (const name of firstNames) {\n    if (!name || name.trim() === '') {\n      firstNameCorrections.push({\n        original: name,\n        corrected: name,\n        needsCorrection: false\n      });\n      continue;\n    }\n    \n    const validation = await validateIndianName(name);\n    \n    firstNameCorrections.push({\n      original: name,\n      corrected: validation.suggestions.length > 0 ? validation.suggestions[0] : name,\n      needsCorrection: !validation.isValid,\n      reason: validation.message\n    });\n  }\n  \n  // Process last names\n  const lastNameCorrections: NameCorrection[] = [];\n  for (const name of lastNames) {\n    if (!name || name.trim() === '') {\n      lastNameCorrections.push({\n        original: name,\n        corrected: name,\n        needsCorrection: false\n      });\n      continue;\n    }\n    \n    const validation = await validateIndianName(name);\n    \n    lastNameCorrections.push({\n      original: name,\n      corrected: validation.suggestions.length > 0 ? validation.suggestions[0] : name,\n      needsCorrection: !validation.isValid,\n      reason: validation.message\n    });\n  }\n  \n  console.log(`[SERVER] Completed batch validation of ${firstNames.length} first names and ${lastNames.length} last names`);\n  \n  return {\n    firstNameCorrections,\n    lastNameCorrections\n  };\n} "],"names":[],"mappings":"AAAA;;CAEC;;;;AAsCD,kEAAkE;AAClE,MAAM,yBAAyB;IAC7B;IAAU;IAAQ;IAAU;IAAS;IAAS;IAAa;IAAQ;IACnE;IAAS;IAAU;IAAS;IAAU;IAAQ;IAAS;IAAU;IACjE;IAAU;IAAS;IAAS;IAAQ;IAAU;IAAS;IAAS;IAChE;IAAO;IAAU;IAAU;IAAQ;IAAU;IAAU;IAAU;IACjE;IAAQ;IAAS;IAAS;IAAU;IAAU;IAAS;IAAS;IAChE;IAAU;IAAS;IAAS;CAC7B;AAED,MAAM,wBAAwB;IAC5B;IAAW;IAAU;IAAU;IAAW;IAAU;IAAO;IAAS;IACpE;IAAS;IAAQ;IAAS;IAAU;IAAQ;IAAS;IAAY;IACjE;IAAU;IAAQ;IAAS;IAAO;IAAS;IAAU;IAAU;IAC/D;IAAS;IAAS;IAAS;IAAQ;IAAU;IAAS;IAAQ;IAC9D;IAAc;IAAQ;IAAY;IAAS;IAAQ;IAAS;IAAS;CACtE;AAED,gCAAgC;AAChC,MAAM,mBAAmB;AACzB,MAAM,qBAAqB;AAC3B,MAAM,8BAA8B;AAYpC,0CAA0C;AAC1C,MAAM,eAAe;IACnB,UAAU;IACV,UAAU;IACV,yBAAyB;IACzB,mBAAmB;IACnB,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;AACnB;AAEA,0BAA0B;AAC1B,MAAM,qBAAqB,CAAC;IAC1B,MAAM,SAAmB,EAAE;IAC3B,IAAI,aAAa;IAEjB,oBAAoB;IACpB,IAAI,KAAK,MAAM,GAAG,GAAG;QACnB,OAAO,IAAI,CAAC,aAAa,QAAQ;QACjC,cAAc;IAChB;IAEA,oBAAoB;IACpB,IAAI,KAAK,IAAI,CAAC,OAAO;QACnB,OAAO,IAAI,CAAC,aAAa,cAAc;QACvC,cAAc;IAChB;IAEA,sEAAsE;IACtE,IAAI,+BAA+B,IAAI,CAAC,OAAO;QAC7C,OAAO,IAAI,CAAC,aAAa,iBAAiB;QAC1C,cAAc;IAChB;IAEA,6BAA6B;IAC7B,IAAI,SAAS,IAAI,CAAC,OAAO;QACvB,OAAO,IAAI,CAAC,aAAa,eAAe;QACxC,cAAc;IAChB;IAEA,yEAAyE;IACzE,MAAM,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC;IACpC,MAAM,yBAAyB,UAAU,KAAK,CAAC,CAAA,OAC7C,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,CAAC,WAAW,MAAM,KAAK,KAAK,CAAC,OAAO,KAAK,KAAK,CAAC,GAAG,WAAW;IAGrG,IAAI,CAAC,wBAAwB;QAC3B,OAAO,IAAI,CAAC,aAAa,uBAAuB;QAChD,cAAc;IAChB;IAEA,4CAA4C;IAC5C,IAAI,UAAU,MAAM,GAAG,GAAG;QACxB,OAAO,IAAI,CAAC,aAAa,eAAe;QACxC,cAAc;IAChB;IAEA,OAAO;QAAE;QAAQ,YAAY,KAAK,GAAG,CAAC,GAAG;IAAY;AACvD;AAEA,oDAAoD;AACpD,MAAM,sBAAsB,CAAC,MAAc;IACzC,MAAM,cAAwB,EAAE;IAChC,MAAM,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC;IAEpC,qBAAqB;IACrB,IAAI,OAAO,QAAQ,CAAC,aAAa,uBAAuB,GAAG;QACzD,MAAM,sBAAsB,UAAU,GAAG,CAAC,CAAA,OACxC,KAAK,MAAM,CAAC,GAAG,WAAW,KAAK,KAAK,KAAK,CAAC,GAAG,WAAW,IACxD,IAAI,CAAC;QAEP,YAAY,IAAI,CAAC;IACnB;IAEA,uBAAuB;IACvB,IAAI,OAAO,QAAQ,CAAC,aAAa,eAAe,GAAG;QACjD,MAAM,cAAc,KAAK,OAAO,CAAC,QAAQ,KAAK,IAAI;QAClD,YAAY,IAAI,CAAC;IACnB;IAEA,iEAAiE;IACjE,IAAI,OAAO,QAAQ,CAAC,aAAa,eAAe,KAAK,UAAU,MAAM,KAAK,GAAG;QAC3E,MAAM,kBAAkB;YAAC;YAAU;YAAS;YAAS;YAAS;YAAS;YAAO;YAAS;YAAQ;SAAQ;QACvG,MAAM,YAAY,SAAS,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,WAAW,KAAK,SAAS,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,WAAW;QAE1F,qCAAqC;QACrC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,MAAM,iBAAiB,eAAe,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,gBAAgB,MAAM,EAAE;YAC1F,YAAY,IAAI,CAAC,GAAG,UAAU,CAAC,EAAE,gBAAgB;QACnD;IACF;IAEA,OAAO;WAAI,IAAI,IAAI;KAAa,EAAE,oBAAoB;AACxD;AAOO,eAAe,mBAAmB,IAAY;IACnD,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,KAAK,CAAC,CAAC;IAExD,yBAAyB;IACzB,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;QACrC,MAAM,IAAI,MAAM;IAClB;IAEA,sDAAsD;IACtD,MAAM,cAAc,KAAK,IAAI;IAE7B,oCAAoC;IACpC,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,mBAAmB;IAElD,uCAAuC;IACvC,MAAM,cAAc,oBAAoB,aAAa;IAErD,+DAA+D;IAC/D,MAAM,UAAU,aAAa;IAE7B,yDAAyD;IACzD,MAAM,UAAU,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,GAAG,UAAU,sBAAsB;IAEhF,MAAM,SAAS;QACb;QACA,MAAM;QACN;QACA;QACA;QACA;IACF;IAEA,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,KAAK,EAAE,CAAC,EAAE;QAAE;QAAS;QAAY,aAAa,OAAO,MAAM;IAAC;IAE3G,OAAO;AACT;AAgBO,eAAe,yBACpB,UAAoB,EACpB,WAAsB;IAKtB,uDAAuD;IACvD,IAAI,CAAC,aAAa;QAChB,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,WAAW,MAAM,CAAC,MAAM,CAAC;QAElE,IAAI,CAAC,MAAM,OAAO,CAAC,aAAa;YAC9B,MAAM,IAAI,MAAM;QAClB;QAEA,gCAAgC;QAChC,MAAM,qBAAqB,WAAW,GAAG,CAAC,CAAA,OAAQ,mBAAmB;QACrE,MAAM,UAAU,MAAM,QAAQ,GAAG,CAAC;QAElC,QAAQ,GAAG,CAAC,CAAC,uCAAuC,EAAE,QAAQ,MAAM,CAAC,MAAM,CAAC;QAE5E,OAAO;IACT;IAEA,yDAAyD;IACzD,MAAM,aAAa;IACnB,MAAM,YAAY;IAElB,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,WAAW,MAAM,CAAC,iBAAiB,EAAE,UAAU,MAAM,CAAC,WAAW,CAAC;IAE3G,sBAAsB;IACtB,MAAM,uBAAyC,EAAE;IACjD,KAAK,MAAM,QAAQ,WAAY;QAC7B,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;YAC/B,qBAAqB,IAAI,CAAC;gBACxB,UAAU;gBACV,WAAW;gBACX,iBAAiB;YACnB;YACA;QACF;QAEA,MAAM,aAAa,MAAM,mBAAmB;QAE5C,qBAAqB,IAAI,CAAC;YACxB,UAAU;YACV,WAAW,WAAW,WAAW,CAAC,MAAM,GAAG,IAAI,WAAW,WAAW,CAAC,EAAE,GAAG;YAC3E,iBAAiB,CAAC,WAAW,OAAO;YACpC,QAAQ,WAAW,OAAO;QAC5B;IACF;IAEA,qBAAqB;IACrB,MAAM,sBAAwC,EAAE;IAChD,KAAK,MAAM,QAAQ,UAAW;QAC5B,IAAI,CAAC,QAAQ,KAAK,IAAI,OAAO,IAAI;YAC/B,oBAAoB,IAAI,CAAC;gBACvB,UAAU;gBACV,WAAW;gBACX,iBAAiB;YACnB;YACA;QACF;QAEA,MAAM,aAAa,MAAM,mBAAmB;QAE5C,oBAAoB,IAAI,CAAC;YACvB,UAAU;YACV,WAAW,WAAW,WAAW,CAAC,MAAM,GAAG,IAAI,WAAW,WAAW,CAAC,EAAE,GAAG;YAC3E,iBAAiB,CAAC,WAAW,OAAO;YACpC,QAAQ,WAAW,OAAO;QAC5B;IACF;IAEA,QAAQ,GAAG,CAAC,CAAC,uCAAuC,EAAE,WAAW,MAAM,CAAC,iBAAiB,EAAE,UAAU,MAAM,CAAC,WAAW,CAAC;IAExH,OAAO;QACL;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/ai/flows/audit-data-for-indian-names.ts"],"sourcesContent":["// Audit Indian names in a dataset.\n\n'use server';\n\nimport {ai, logGeminiAPICall} from '@/ai/ai-instance';\nimport {validateIndianName, batchValidateIndianNames} from '@/services/indian-name-validator-server';\nimport {z} from 'genkit';\n\nconst AuditDataForIndianNamesInputSchema = z.object({\n  data: z\n    .array(z.record(z.string()))\n    .describe('An array of data records, where each record is a map of string to string.'),\n});\nexport type AuditDataForIndianNamesInput = z.infer<typeof AuditDataForIndianNamesInputSchema>;\n\nconst AuditDataForIndianNamesOutputSchema = z.object({\n  anomalies: z.array(\n    z.object({\n      row: z.number().describe('The row number where the anomaly was found.'),\n      column: z.string().describe('The column name where the anomaly was found.'),\n      value: z.string().describe('The value that was flagged as an anomaly.'),\n      message: z.string().describe('The reason why the value was flagged as an anomaly.'),\n      suggestion: z.string().optional().describe('A suggested correction for the anomaly.'),\n    })\n  ),\n});\nexport type AuditDataForIndianNamesOutput = z.infer<typeof AuditDataForIndianNamesOutputSchema>;\n\nexport async function auditDataForIndianNames(\n  input: AuditDataForIndianNamesInput\n): Promise<AuditDataForIndianNamesOutput> {\n  console.log(\"[SERVER] 🤖 Calling Gemini API for auditDataForIndianNames flow\");\n  logGeminiAPICall(`Starting auditDataForIndianNames flow with ${input.data.length} records`);\n  \n  const result = await auditDataForIndianNamesFlow(input);\n  \n  console.log(\"[SERVER] 🤖 Gemini API call completed for auditDataForIndianNames flow\");\n  logGeminiAPICall(`Completed auditDataForIndianNames flow with ${result.anomalies.length} anomalies`);\n  \n  return result;\n}\n\nconst auditDataForIndianNamesFlow = ai.defineFlow(\n  {\n    name: 'auditDataForIndianNamesFlow',\n    inputSchema: AuditDataForIndianNamesInputSchema,\n    outputSchema: AuditDataForIndianNamesOutputSchema,\n  },\n  async input => {\n    console.log(\"[SERVER] 🤖 Starting Gemini API flow execution\");\n    logGeminiAPICall(`Executing AI flow for data auditing - processing data`);\n    \n    const anomalies: AuditDataForIndianNamesOutput['anomalies'] = [];\n\n    // Define the name columns to check\n    const firstNameColumn = 'Accused First Name';\n    const lastNameColumn = 'Accused Last Name';\n    const inspectorColumn = 'Inspector In charge';\n    \n    // Extract all names from each column\n    const firstNames: string[] = [];\n    const lastNames: string[] = [];\n    const inspectorNames: string[] = [];\n    \n    // Map row indices to keep track of original positions\n    const firstNameIndices: number[] = [];\n    const lastNameIndices: number[] = [];\n    const inspectorIndices: number[] = [];\n    \n    // Collect all names and their row indices\n    for (let i = 0; i < input.data.length; i++) {\n      const row = input.data[i];\n      \n      if (row[firstNameColumn]?.trim()) {\n        firstNames.push(row[firstNameColumn]);\n        firstNameIndices.push(i);\n      }\n      \n      if (row[lastNameColumn]?.trim()) {\n        lastNames.push(row[lastNameColumn]);\n        lastNameIndices.push(i);\n      }\n      \n      if (row[inspectorColumn]?.trim()) {\n        inspectorNames.push(row[inspectorColumn]);\n        inspectorIndices.push(i);\n      }\n    }\n    \n    // Process first names and last names in batches\n    try {\n      console.log(`Processing ${firstNames.length} first names and ${lastNames.length} last names`);\n      logGeminiAPICall(`Validating ${firstNames.length} first names and ${lastNames.length} last names`);\n      \n      const nameValidationResults = await batchValidateIndianNames(\n        firstNames, \n        lastNames\n      );\n      \n      const { firstNameCorrections, lastNameCorrections } = nameValidationResults;\n      \n      // Process first name corrections\n      for (let i = 0; i < firstNameCorrections.length; i++) {\n        const correction = firstNameCorrections[i];\n        if (correction.needsCorrection) {\n          anomalies.push({\n            row: firstNameIndices[i] + 1, // Convert to 1-indexed\n            column: firstNameColumn,\n            value: correction.original,\n            message: correction.reason || 'Name requires correction',\n            suggestion: correction.corrected,\n          });\n        }\n      }\n      \n      // Process last name corrections\n      for (let i = 0; i < lastNameCorrections.length; i++) {\n        const correction = lastNameCorrections[i];\n        if (correction.needsCorrection) {\n          anomalies.push({\n            row: lastNameIndices[i] + 1, // Convert to 1-indexed\n            column: lastNameColumn,\n            value: correction.original,\n            message: correction.reason || 'Name requires correction',\n            suggestion: correction.corrected,\n          });\n        }\n      }\n      \n      // Process inspector names separately (not in batch)\n      for (let i = 0; i < inspectorNames.length; i++) {\n        const value = inspectorNames[i];\n        console.log(\"value\", value);\n        const nameInfo = await validateIndianName(value);\n        \n        if (!nameInfo.isValid) {\n          anomalies.push({\n            row: inspectorIndices[i] + 1, // Convert to 1-indexed\n            column: inspectorColumn,\n            value: value,\n            message: nameInfo.message || 'The value is potentially not a valid Indian name.',\n            suggestion: nameInfo.suggestions && nameInfo.suggestions.length > 0 ? nameInfo.suggestions[0] : '',\n          });\n        }\n      }\n    } catch (error) {\n      console.error(\"Error in batch name validation:\", error);\n      logGeminiAPICall(`Error during name validation: ${error instanceof Error ? error.message : String(error)}`);\n      \n      // Fallback to individual validation in case of batch error\n      console.log(\"Falling back to individual name validation\");\n      for (let i = 0; i < input.data.length; i++) {\n        const row = input.data[i];\n        \n        // Only check name columns\n        const nameColumns = [firstNameColumn, lastNameColumn, inspectorColumn];\n        \n        for (const column of nameColumns) {\n          if (Object.prototype.hasOwnProperty.call(row, column)) {\n            const value = row[column];\n            \n            // Skip empty values\n            if (!value || value.trim() === '') continue;\n            \n            console.log(\"value\", value);\n            const nameInfo = await validateIndianName(value);\n            \n            if (!nameInfo.isValid) {\n              anomalies.push({\n                row: i + 1,\n                column: column,\n                value: value,\n                message: nameInfo.message || 'The value is potentially not a valid Indian name.',\n                suggestion: nameInfo.suggestions && nameInfo.suggestions.length > 0 ? nameInfo.suggestions[0] : '',\n              });\n            }\n          }\n        }\n      }\n    }\n\n    logGeminiAPICall(`AI flow completed - found ${anomalies.length} anomalies`);\n    return {anomalies};\n  }\n);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/ai/flows/provide-data-audit-summary.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Summarizes potential data quality issues after an audit.\n *\n * - provideDataAuditSummary - A function that provides a textual summary of potential data issues.\n * - ProvideDataAuditSummaryInput - The input type for the provideDataAuditSummary function.\n * - ProvideDataAuditSummaryOutput - The return type for the provideDataAuditSummary function.\n */\n\nimport {ai} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\nconst ProvideDataAuditSummaryInputSchema = z.object({\n  auditResults: z.string().describe('The detailed results from the data audit.'),\n});\nexport type ProvideDataAuditSummaryInput = z.infer<typeof ProvideDataAuditSummaryInputSchema>;\n\nconst ProvideDataAuditSummaryOutputSchema = z.object({\n  summary: z.string().describe('A textual summary of the potential data quality issues.'),\n});\nexport type ProvideDataAuditSummaryOutput = z.infer<typeof ProvideDataAuditSummaryOutputSchema>;\n\nexport async function provideDataAuditSummary(input: ProvideDataAuditSummaryInput): Promise<ProvideDataAuditSummaryOutput> {\n  return provideDataAuditSummaryFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'provideDataAuditSummaryPrompt',\n  input: {\n    schema: z.object({\n      auditResults: z.string().describe('The detailed results from the data audit.'),\n    }),\n  },\n  output: {\n    schema: z.object({\n      summary: z.string().describe('A textual summary of the potential data quality issues.'),\n    }),\n  },\n  prompt: `You are an AI assistant who summarizes data audit results.\n\n  Given the following data audit results, provide a concise textual summary of the potential data quality issues identified. Focus on the key findings and potential implications for data accuracy and reliability.\n  \\n  Audit Results: {{{auditResults}}}\n  \\n  Summary: `,\n});\n\nconst provideDataAuditSummaryFlow = ai.defineFlow<\n  typeof ProvideDataAuditSummaryInputSchema,\n  typeof ProvideDataAuditSummaryOutputSchema\n>(\n  {\n    name: 'provideDataAuditSummaryFlow',\n    inputSchema: ProvideDataAuditSummaryInputSchema,\n    outputSchema: ProvideDataAuditSummaryOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,qCAAqC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACpC;AAGA,MAAM,sCAAsC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnD,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAGO,eAAe,uCAAqB,GAArB,wBAAwB,KAAmC;IAC/E,OAAO,4BAA4B;AACrC;AAEA,MAAM,SAAS,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACpC;IACF;IACA,QAAQ;QACN,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC/B;IACF;IACA,QAAQ,CAAC;;;;eAII,CAAC;AAChB;AAEA,MAAM,8BAA8B,2HAAA,CAAA,KAAE,CAAC,UAAU,CAI/C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAnCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 762, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/ai/flows/suggest-data-corrections.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines a Genkit flow for suggesting corrections to Indian names.\n *\n * - suggestDataCorrections - A function that initiates the name correction suggestion process.\n * - SuggestDataCorrectionsInput - The input type for the suggestDataCorrections function, including the array of names.\n * - SuggestDataCorrectionsOutput - The return type for the suggestDataCorrections function, providing suggestions for name corrections.\n */\n\nimport {ai, logGeminiAPICall} from '@/ai/ai-instance';\nimport {z} from 'genkit';\n\n// Define the name correction type\ninterface NameCorrection {\n  originalName: string;\n  suggestedName: string;\n  hasCorrection: boolean;\n  reason?: string;\n}\n\nconst SuggestDataCorrectionsInputSchema = z.object({\n  names: z.array(z.string()).describe('An array of Indian names to be validated and corrected.'),\n});\nexport type SuggestDataCorrectionsInput = z.infer<typeof SuggestDataCorrectionsInputSchema>;\n\nconst SuggestDataCorrectionsOutputSchema = z.object({\n  correctionResults: z.array(\n    z.object({\n      originalName: z.string().describe('The original name.'),\n      suggestedName: z.string().describe('The suggested correction or original name if no correction needed.'),\n      hasCorrection: z.boolean().describe('Whether a correction was made.'),\n      reason: z.string().optional().describe('The reason for the correction.'),\n    })\n  ).describe('An array of name corrections with detailed information.')\n});\nexport type SuggestDataCorrectionsOutput = z.infer<typeof SuggestDataCorrectionsOutputSchema>;\n\nexport async function suggestDataCorrections(input: SuggestDataCorrectionsInput): Promise<SuggestDataCorrectionsOutput> {\n  try {\n    logGeminiAPICall(`Starting name correction flow for ${input.names.length} names`);\n    \n    // Print input names to console\n    console.log('📥 INPUT NAMES:', JSON.stringify(input.names, null, 2));\n    \n    // Convert the input array to a JSON string for the prompt\n    const namesObject = {\n      names: input.names\n    };\n    const namesJson = JSON.stringify(namesObject, null, 2);\n    \n    const result = await suggestDataCorrectionsFlow({\n      namesJson\n    });\n    \n    // Print output corrections to console\n    console.log('📤 OUTPUT CORRECTIONS:', JSON.stringify(result.correctionResults, null, 2));\n    \n    logGeminiAPICall(`Completed name correction flow with ${result.correctionResults.length} results`);\n    return result;\n  } catch (error) {\n    // Log the error but don't try to call toast here\n    console.error('Error in name correction flow:', error);\n    \n    // Return a valid response with empty corrections\n    return {\n      correctionResults: []\n    };\n  }\n}\n\nconst prompt = ai.definePrompt({\n  name: 'suggestIndianNameCorrectionsPrompt',\n  input: {\n    schema: z.object({\n      namesJson: z.string().describe('JSON string containing an array of Indian names.'),\n    }),\n  },\n  output: {\n    schema: z.object({\n      correctionResults: z.array(\n        z.object({\n          originalName: z.string(),\n          suggestedName: z.string(),\n          hasCorrection: z.boolean(),\n          reason: z.string().optional(),\n        })\n      ),\n    }),\n  },\n  prompt: `You are an AI assistant specialized in Indian name validation and correction.\n\nYou are provided with a JSON string containing an array of Indian names. Your task is to:\n1. Parse the JSON string into an object\n2. For each name in the array, check if there are any spelling mistakes or formatting issues\n3. Generate a correction if needed, keeping the cultural context of Indian names intact\n4. Provide the reason for any correction made\n\nCommon issues with Indian names include:\n- Incorrect capitalization (e.g., \"rahul sharma\" should be \"Rahul Sharma\")\n- Missing spaces between first and last names\n- Misspelled common Indian names\n- Incorrect placement of syllables\n\nIMPORTANT RULES:\n- If the name is already correct, suggest the same name and set hasCorrection to false\n- Always respect the cultural integrity of the name\n- Look for common Indian first and last names as reference\n- Maintain the same general structure of the name unless there's a clear error\n- Do not change naming conventions across regions (South Indian vs North Indian naming patterns)\n\nInput JSON:\n{{{namesJson}}}\n\nPlease provide your analysis and corrections in the following JSON format:\n{\n  \"correctionResults\": [\n    {\n      \"originalName\": \"original name\",\n      \"suggestedName\": \"corrected name\",\n      \"hasCorrection\": true/false,\n      \"reason\": \"explanation for correction (if applicable)\"\n    },\n    ...\n  ]\n}\n`,\n});\n\nconst suggestDataCorrectionsFlowSchema = z.object({\n  namesJson: z.string().describe('JSON string containing an array of Indian names.'),\n});\n\nconst suggestDataCorrectionsFlow = ai.defineFlow<\n  typeof suggestDataCorrectionsFlowSchema,\n  typeof SuggestDataCorrectionsOutputSchema\n>(\n  {\n    name: 'suggestDataCorrectionsFlow',\n    inputSchema: suggestDataCorrectionsFlowSchema,\n    outputSchema: SuggestDataCorrectionsOutputSchema,\n  },\n  async input => {\n    logGeminiAPICall(`Processing names through Gemini API`);\n    console.log('🔄 PROCESSING: Sending input to Gemini API:', input.namesJson);\n    \n    const {output} = await prompt(input);\n    \n    console.log('✅ RECEIVED: Response from Gemini API:', JSON.stringify(output, null, 2));\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAUA,MAAM,oCAAoC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACjD,OAAO,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;AACtC;AAGA,MAAM,qCAAqC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,mBAAmB,uIAAA,CAAA,IAAC,CAAC,KAAK,CACxB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACP,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAClC,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACnC,eAAe,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;QACpC,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACzC,IACA,QAAQ,CAAC;AACb;AAGO,eAAe,uCAAoB,GAApB,uBAAuB,KAAkC;IAC7E,IAAI;QACF,CAAA,GAAA,2HAAA,CAAA,mBAAgB,AAAD,EAAE,CAAC,kCAAkC,EAAE,MAAM,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;QAEhF,+BAA+B;QAC/B,QAAQ,GAAG,CAAC,mBAAmB,KAAK,SAAS,CAAC,MAAM,KAAK,EAAE,MAAM;QAEjE,0DAA0D;QAC1D,MAAM,cAAc;YAClB,OAAO,MAAM,KAAK;QACpB;QACA,MAAM,YAAY,KAAK,SAAS,CAAC,aAAa,MAAM;QAEpD,MAAM,SAAS,MAAM,2BAA2B;YAC9C;QACF;QAEA,sCAAsC;QACtC,QAAQ,GAAG,CAAC,0BAA0B,KAAK,SAAS,CAAC,OAAO,iBAAiB,EAAE,MAAM;QAErF,CAAA,GAAA,2HAAA,CAAA,mBAAgB,AAAD,EAAE,CAAC,oCAAoC,EAAE,OAAO,iBAAiB,CAAC,MAAM,CAAC,QAAQ,CAAC;QACjG,OAAO;IACT,EAAE,OAAO,OAAO;QACd,iDAAiD;QACjD,QAAQ,KAAK,CAAC,kCAAkC;QAEhD,iDAAiD;QACjD,OAAO;YACL,mBAAmB,EAAE;QACvB;IACF;AACF;AAEA,MAAM,SAAS,2HAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QACL,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACjC;IACF;IACA,QAAQ;QACN,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;YACf,mBAAmB,uIAAA,CAAA,IAAC,CAAC,KAAK,CACxB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;gBACP,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM;gBACtB,eAAe,uIAAA,CAAA,IAAC,CAAC,MAAM;gBACvB,eAAe,uIAAA,CAAA,IAAC,CAAC,OAAO;gBACxB,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;YAC7B;QAEJ;IACF;IACA,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCX,CAAC;AACD;AAEA,MAAM,mCAAmC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACjC;AAEA,MAAM,6BAA6B,2HAAA,CAAA,KAAE,CAAC,UAAU,CAI9C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,CAAA,GAAA,2HAAA,CAAA,mBAAgB,AAAD,EAAE,CAAC,mCAAmC,CAAC;IACtD,QAAQ,GAAG,CAAC,+CAA+C,MAAM,SAAS;IAE1E,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAE9B,QAAQ,GAAG,CAAC,yCAAyC,KAAK,SAAS,CAAC,QAAQ,MAAM;IAClF,OAAO;AACT;;;IAhHoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 979, "column": 0}, "map": {"version":3,"sources":["file:///home/kai/code/Name_corrector_h4b/src/app/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgQ,GAC7R,8BACA","debugId":null}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}